#version 450

#include "lib/lighting.glsl"
#include "lib/gbuffer.glsl"
#include "lib/sh.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform sampler2D in_depth; // Not needed ?
layout(set = 0, binding = 1) uniform sampler2D in_color;
layout(set = 0, binding = 2) uniform sampler2D in_normal;

layout(set = 0, binding = 3) uniform CameraData {
	Camera camera;
};

layout(set = 0, binding = 4) readonly buffer SHBuffer {
	SH probes[];
};

layout(rgba16f, set = 0, binding = 5) uniform writeonly image2D out_color;


void main() {
	const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

	const float depth = texelFetch(in_depth, coord, 0).x;
	if(is_OOB(depth)) {
		return;
	}
	const vec3 world_pos = unproject(uv, depth, camera.inv_view_proj);

	vec3 albedo;
	float metallic;
	vec3 normal;
	float roughness;
	unpack_color(texelFetch(in_color, coord, 0), albedo, metallic);
	unpack_normal(texelFetch(in_normal, coord, 0), normal, roughness);

	const vec3 uvw = saturate((world_pos + 1000.0) / 2000.0);

	const uvec3 indexes = uvec3(uvw * 10.0);
	uint index = 0;
	index += uint(indexes.x * 100);
	index += uint(indexes.y * 10);
	index += uint(indexes.z * 1);

	vec3 irradiance = uvw;
	float mi = min(uvw.x, min(uvw.y, uvw.z));
	float ma = max(uvw.x, max(uvw.y, uvw.z));
	if(mi <= 0.0 || ma >= 1.0) {
		irradiance = vec3(0.0, 0.0, 1.0);
	} else {
		const SH sh = probes[index];
		irradiance = eval_sh(sh, normal); /* * albedo*/;
	}

	imageStore(out_color, coord, vec4(irradiance, 1.0));
}


