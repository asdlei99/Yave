#version 450

#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "lib/utils.glsl"
#include "lib/gbuffer.glsl"

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0) uniform sampler2D in_depth;
layout(set = 0, binding = 1) uniform sampler2D in_rt0;
layout(set = 0, binding = 2) uniform sampler2D in_rt1;

layout(set = 0, binding = 3) uniform CameraData {
    Camera camera;
};

layout(set = 0, binding = 4) writeonly buffer Probes {
    vec4 probe_positions[];
};

// Should be gl_NumSubgroups, do we just set 64 and pray?
shared vec4 sub_pos[64];
shared vec4 sub_norm[64];

void main() {
    const uint group_index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;

    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 input_size = ivec2(textureSize(in_depth, 0).xy);
    const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(input_size);

    const float depth = texelFetch(in_depth, coord, 0).x;

    const vec3 normal = read_gbuffer(texelFetch(in_rt0, coord, 0), texelFetch(in_rt1, coord, 0)).normal;
    const vec3 world_pos = unproject(uv, depth, camera.inv_view_proj);
    const float cam_dist = length(world_pos - camera.position);

    const bool in_bounds = !(is_OOB(depth) || any(greaterThan(coord, input_size)) || any(lessThan(coord, ivec2(0))));

    if(subgroupElect()) {
        sub_pos[gl_SubgroupID] = vec4(0.0);
        sub_norm[gl_SubgroupID] = vec4(0.0);
    }

    subgroupBarrier();

    if(in_bounds) {
        const vec4 pos = subgroupAdd(vec4(world_pos, 1.0));
        const vec4 norm = subgroupAdd(vec4(normal, 1.0));
        if(subgroupElect()) {
            sub_pos[gl_SubgroupID] = pos;
            sub_norm[gl_SubgroupID] = norm;
        }
    }

    barrier();

    if(gl_LocalInvocationIndex == 0) {
        vec4 pos = vec4(0.0);
        vec4 norm = vec4(0.0);
        for(uint i = 0; i != gl_NumSubgroups; ++i) {
            pos += sub_pos[i];
            norm += sub_norm[i];
        }

        const bool valid = pos.w > 0.0 && length(norm.xyz) > 0.0;
        if(valid) {
            const vec3 base_pos = pos.xyz / pos.w + normalize(norm.xyz)/* * min(0.25, cam_dist * 0.5)*/;
            probe_positions[group_index] = vec4(round(base_pos), 0.0);
        } else {
            probe_positions[group_index] = vec4(0.0, 0.0, 0.0, 1.0);
        }
    }
}

