#version 450

#extension GL_EXT_shader_image_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

#include "lib/utils.glsl"
#include "lib/surfels.glsl"


// -------------------------------- I/O --------------------------------

layout(local_size_x = 64) in;

layout(r64ui, set = 0, binding = 0) uniform u64image3D out_probes;

layout(set = 0, binding = 1) uniform CameraData {
    Camera camera;
};

layout(set = 0, binding = 2) readonly buffer Surfels {
    SurfelData surfels[];
};

layout(set = 0, binding = 3) readonly buffer Instances {
    InstanceData instances[];
};

layout(set = 0, binding = 4) readonly buffer Probes {
    vec4 probe_positions[];
};



// -------------------------------- MAIN --------------------------------

// https://math.stackexchange.com/questions/73238/calculating-solid-angle-for-a-sphere-in-space
float compute_screen_fraction(InstanceData instance, vec3 position) {
    const vec3 to_center = position - instance.center;
    const float dist_sq = dot(to_center, to_center);
    const float radius_sq = sqr(instance.radius);
    if(dist_sq <= radius_sq) {
        return 1.0;
        // return 99999.0;
    }
    return 0.5 * (1.0 - sqrt(dist_sq - radius_sq) / sqrt(dist_sq));
}


void main() {
    const vec4 probe_data = probe_positions[gl_GlobalInvocationID.y];
    if(probe_data.w > 0.0) {
        return;
    }

    const InstanceData instance = instances[gl_WorkGroupID.x];

    const float fraction = compute_screen_fraction(instance, probe_data.xyz) * 2.0;
    const vec2 image_size = vec2(imageSize(out_probes).xy);
    const float screen_size_px = (image_size.x * image_size.y) * fraction;

    const uint splats = min(instance.surfel_count, uint(screen_size_px + 1.0));
    for(uint i = gl_LocalInvocationIndex ; i < splats; i += gl_WorkGroupSize.x) {
        const uint surfel_index = instance.surfel_offset + i;
        const Surfel surfel = to_surfel(surfels[surfel_index]);

        const vec3 to_probe = (probe_data.xyz - surfel.pos);
        const float probe_dist = length(to_probe);
        const vec3 probe_dir = to_probe / probe_dist;

        /*if(dot(surfel.norm, to_probe) > 0.0) {
            continue;
        }*/

        const vec2 uv = octahedron_encode(probe_dir);
        const vec2 coord = round(saturate(uv) * image_size);
        const uint depth_val = floatBitsToUint(probe_dist);
        imageAtomicMin(out_probes, ivec3(coord, gl_GlobalInvocationID.y), pack_64(uvec2(depth_val, surfel_index)));
    }
}

