#version 450

#include "lib/surfels.glsl"

// -------------------------------- I/O --------------------------------

layout(local_size_x = 8, local_size_y = 8) in;

layout(r64ui, set = 0, binding = 0) uniform u64image3D inout_probes;

layout(set = 0, binding = 1) readonly buffer Surfels {
    Surfel surfels[];
};

layout(set = 0, binding = 2) readonly buffer Probes {
    vec4 probe_positions[];
};


void main() {
    const vec4 probe_data = probe_positions[gl_GlobalInvocationID.z];
    if(probe_data.w > 0.0) {
        return;
    }

    const uvec2 content = unpack_64(imageLoad(inout_probes, ivec3(gl_GlobalInvocationID)).x);
    if(content.y == max_uint) {
        return;
    }

    const uint surfel_index = content.y;
    const Surfel surfel = surfels[surfel_index];

    const vec3 tangent = build_tangent(surfel.norm);
    const vec3 binormal = cross(tangent, surfel.norm);

    const vec2 image_size = vec2(imageSize(inout_probes).xy);

    const int kernel_size = 4;
    for(int x = -kernel_size; x <= kernel_size; ++x) {
        for(int y = -kernel_size; y <= kernel_size; ++y) {
            const ivec2 coord = ivec2(gl_GlobalInvocationID.xy) + ivec2(x, y);
            const vec3 dir = normalize(octahedron_decode(coord / image_size));

            const float d = dot(surfel.pos - probe_data.xyz, surfel.norm) / dot(dir, surfel.norm);
            const vec3 proj = probe_data.xyz + dir * d;
            const vec3 to_proj = surfel.pos - proj;
            /*if(dot(to_proj, to_proj) < 1.0)*/ {
                imageAtomicMin(inout_probes, ivec3(coord, gl_GlobalInvocationID.z), pack_64(uvec2(floatBitsToUint(d), 2)));
            }
        }
    }

    const vec3 proj = project_surfel(surfel, probe_data.xyz);
    vec2 coord = round(saturate(proj.xy) * image_size);
    imageStore(inout_probes, ivec3(coord, gl_GlobalInvocationID.z), pack_64(uvec2(0, 1)).xxxx);

}

